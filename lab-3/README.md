# Низкоуровневое программирование. Лабораторная работа №3

## Цели и задачи лабораторной работы

**Цель лабораторной работы**: изучение взаимодействия с внешним
кодом, методов компиляции и компоновки исполняемых файлов, основ
дизассемблирования.

**Задание на лабораторную работу:** реализовать две программы
согласно варианту на лабораторную работу.

## Введение

### Исторические сведения

Еще со времен существования ассемблера, как основного способа
программирования программистам приходилось вырабатывать некие
общие соглашения о том, как им следует писать программный код, чтобы
остальные программисты могли далее с ним работать. Как правило,
подобные соглашения были своими для каждой фирмы и явно
документировались при передаче программного кода за пределы фирмы.

С появлением компиляторов данная проблема стала решаться
автоматически, однако данные соглашения по-прежнему были своими для
каждого компилятора. К примеру, компилятор языка Pascal мог
использовать свое соглашение о вызовах, отличное от компилятора языка
C, а компилятор для языка С от Wacom мог использовать соглашение,
отличное от компилятора С от Microsoft.

Начиная с 2000-х годов на рынке компиляторов С/С++
доминирующими силами остались компиляторы Microsoft Visual C++
Compiler и семейство компиляторов GNU Compiler Collection (включает в
себя компиляторы g++ и gcc). Каждая из сторон использует собственные
соглашения и нацелена на свою платформу (Windows и Linux/UNIX), хотя
GCC может, при необходимости, собирать код для Windows. Остальные
компиляторы: Intel C++ Compiler, Clang, Embarcadero C++ Builder по
умолчанию подстраиваются под одну из этих сторон.

Помимо компиляторов, существенное влияние на программные
соглашения также определяет целевая операционная система. В частности,
ОС регламентирует форматы исполняемых файлов и способы
взаимодействия программы и ОС.

Суммарно набор всех программных соглашений, действующих на
уровне двоичного кода, называется ABI (Application Binary Interface,
двоичный интерфейс приложений). ABI включает в себя форматы файлов
(исполняемые файлы, статические и динамические библиотеки),
требования к точке входа в программу, механизм системных вызовов и пр.
В рамках данной лабораторной работы наиболее важной составляющей ABI являются
**соглашения о вызовах** – набор правил, по которым происходит вызов
функций.

Существовал целый ряд соглашений о вызовах для 32-битных систем
(cdecl, stdcall, pascal, fastcall, thiscall). С приходом 64-битных систем
осталось только 2 основных соглашения о вызовах: Microsoft x64 и System
V x64.

### Основные определения

**Соглашение о вызове** - набор правил, регламентирующих вызов
функций.

**Неизменяемые регистры** – регистры, содержание которых до и
после вызова функции неизменно.

**Изменяемые регистры** – регистры, содержание которых до и после
вызова функции может (но не обязано) отличаться.

**POD-структура** (Plain Old Data) – структура, имеющая тривиальные
обычный конструктор, деструктор, конструктор копирования и оператор
присваивания. Все структуры языка С являются POD-структурами.
Классы и структуры языка С++ являются POD-структурами при указанных
выше ограничениях.

**Единица трансляции** – файл, содержащий определения глобальных
переменных и функций. Обычно - `.c`/`.cpp`/`.cxx` файл.
Объектный файл – файл, являющийся результатом компиляции
единицы трансляции. Объектный файл содержит машинный код и таблицы
символов.

**Символ** – уникальное в пределах единицы трансляции имя.
Символами являются имена функций и глобальных переменных.

**Таблица символов** – таблица, сопоставляющая символы и их
определения.

**Таблица экспорта** – таблица символов, в которой перечислены
адреса видимых на этапе компоновки символов, для которых объектный
файл предоставляет определения.

**Таблица импорта** – таблица символов, в которой перечислены
символы, используемые в объектном файле, но определение которых в
самом объектном файле отсутствует.

**Компоновка** – процесс сборки программы из объектных файлов и
других исполняемых файлов.

**Статическая компоновка** – компоновка, происходящая во время
создания исполняемого файла программы.

**Динамическая компоновка** – компоновка, происходящая во время
загрузки программы из исполняемого файла и во время исполнения самой
программы.

## Соглашения о вызовах

### Соглашения для х86

Соглашения, действовавшие во времена 32-битных платформ
интенсивно используют стек для передачи параметров. Возврат результата
происходит в регистре EAX (`char`/`shrot`/`int` или указатель), паре
регистров [EDX:EAX] (`long long`/POD-структуры размером $<=$ 8 байт) или
`ST0` (вещественные числа).

Характеристики соглашений о вызовах приведены в таблице:

|     |     |     |     |     |
| --- | --- | --- | --- | --- | 
| **Соглашение** | cdecl(GCC) | cdecl(MSVC) | stdcall | thiscall |
| **Изменяемые регистры** | `eax`, `ecx`, `edx`, `st0`-`st7` (см. ниже), `xmm0`-`xmm7` | `eax`, `ecx`, `edx`, `st0`-`st7` (см. ниже), `xmm0`-`xmm7` | `eax`, `ecx`, `edx`, `st0`-`st7` (см. ниже), `xmm0`-`xmm7` | `eax`, `ecx`, `edx`, `st0`-`st7` (см. ниже), `xmm0`-`xmm7` |
| **Неизменяемые регистры** | `esp`, `ebp`, `ebx`, `esi`, `edi`, `mxcsr`, `xmm7`-`xmm15`, управляющие регистры х87 | `esp`, `ebp`, `ebx`, `esi`, `edi`, `mxcsr`, `xmm7`-`xmm15`, управляющие регистры х87 | `esp`, `ebp`, `ebx`, `esi`, `edi`, `mxcsr`, `xmm7`-`xmm15`, управляющие регистры х87 | `esp`, `ebp`, `ebx`, `esi`, `edi`, `mxcsr`, `xmm7`-`xmm15`, управляющие регистры х87 |
| **Передача аргументов** | На стеке в обратном порядке (см. ниже) | a | a | a |
| **Указатель this** | 1-ый аргумент | 1-ый аргумент | 1-ый аргумент | `ecx` | 
| **Очистка стека от аргументов** | Вызывающая функция | Вызывающая функция | Вызываемая функция | Вызываемая функция |
| **Возврат результата** |  |  |  |  |
| `char`/`short`/`int` | `eax` | `eax` | `eax` | `eax` |
| **Указатель** | `eax` | `eax` | `eax` | `eax` |
|`long long` | `edx:eax` | `edx:eax` | `edx:eax` | `edx:eax` |
|`float`/`double` | `st0` | `st0` | `st0` | `st0` |
| **POD-структура менее 8 байт** | в буфер возврата (первый скрытый аргумент, убирает вызываемая функция) | `edx:eax` | `edx:eax` | `edx:eax` |
| **Остальные структуры** | в буфер возврата (первый скрытый аргумент, убирает вызываемая функция) | в буфер возврата (второй после `this` аргумент) | в буфер возврата (второй после `this` аргумент) | в буфер возврата (первый аргумент) |

Аргумент на стеке не может занимать менее 4 байт. Даже если
аргумент – `char`, на стек будет положен `int` (4 байта). Если структура
занимает 7 байт – на стек будет положено 8 байт ($2 \cdot 4$).

Особые указания относятся к стеку сопроцессора. По общему
правилу, стек должен быть пуст в момент вызова функции, а в момент
выхода из функции должен либо содержать результат в ST0, либо быть
пустым.

### Соглашения для х86-64

Соглашения для 64-битных платформ более интенсивно используют
регистры для передачи параметров.

Общим для обоих соглашений является 
**требование к выравниванию стека**: 
*стек в момент вызова функции обязан быть выровнен по границе 16 байт*:
`RSP % 16 == 0`. Т.е., в момент входа в
функцию справедливо равенство `RSP % 16 == 8`, т.к. в момент вызова
функции стек был выровнен по границе 16 байт, а на стек положили адрес
возврата, размером 8 байт.

Характеристики соглашений о вызовах приведены в таблице:

|     |     |     |
| --- | --- | --- |
| **Соглашение** | System V | Microsoft |
| **Изменяемые регистры** | `rax`, `rcx`, `rdx`, `rsi`, `rdi`, `r8`-`r11`, `xmm0`-`xmm15` | `rax`, `rcx`, `rdx`, `r8`-`r11`, `xmm0`-`xmm5` |
| **Неизменяемые регистры** | `rbx`, `rbp`, `r12`-`r15` | `rbx`, `rsi`, `rdi`, `rbp`, `r12`-`r15`, `xmm6`-`xmm15` |
| **Передача целочисленных аргументов** | `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`, далее на стеке | `rcx`, `rdx`, `r8`, `r9`+`shadow space`, далее на стеке |
| **Передача вещественных аргументов** | `xmm0`-`xmm7`, далее на стеке (см. ниже) |`xmm0`-`xmm3`, далее на стеке (см. ниже) |
| **Указатель** `this` | Первый аргумент |  Первый аргумент |
| **Тривиально копируемая структура не более 8 байт** | В регистре или на стеке, согласно порядковому номеру аргумента | В регистре или на стеке, согласно порядковому номеру аргумента |
| **Тривиально копируемая структура не более 16 байт** | Если есть 2 свободных регистра – то в них. Иначе – см. Microsoft | Через временную копию, аргумент – указатель на копию |
| **Остальные структуры** | через временную копию, аргумент – указатель на копию | через временную копию, аргумент – указатель на копию |
| **Очистка стека от аргументов** | Вызывающая функция | Вызывающая функция |
| **Возврат результата** | | |
| `char`/`short`/`int` | `rax` | `rax` |
| **Указатель** | `rax` | `rax` |
| `long long` | `rax` | `rax` |
| `float`/`double` | `xmm0` | `xmm0` |
| **POD-структура не более 8 байт** | `rax` | `rax` | 
| **POD-структура не более 16 байт** | младшая часть – `rax`/`xmm0`, старшая часть – `rdx`/`xmm1` | в буфер на стеке, указатель на буфер – второй после `this` аргумент |
| **Остальные структуры** | в буфер на стеке, указатель на буфер – первый аргумент |  в буфер на стеке, указатель на буфер – второй после `this` аргумент |

#### Соглашение System V

Передача простых аргументов в соглашении System V описывается
кратко: аргументы передаются в регистрах по порядку в таблице выше, если
все регистры заполнены – на стеке.

Если функция имеет переменное число параметров (например, как
`printf`/`scanf`), то дополнительно в `RAX` передается количество занятых
вещественными аргументами XMM-регистров.

Если структура имеет тривиальный конструктор
перемещения/копирования и тривиальный деструктор (обычный
конструктор может быть нетривиальным), то она может быть передана в
регистрах. При этом:
- Если структура имеет размер 8 или менее байт, и имеет 
*только вещественные поля*, она передается в следующем свободном XMM-
регистре.
- Если структура имеет размер 8 или менее байт, и имеет
*целочисленные* или *целочисленные и вещественные* поля, она передается в
следующем свободном регистре общего назначения.
- Если структура имеет размер от 9 до 16 байт, она разбивается на 2
части по 8 байт, каждая из которых передается, согласно правилу для 8-байтных
структур.
- Если половина структуры поместилась, а половина - нет, она целиком
передается через указатель на копию.
- Если структура не может быть передана в регистрах, то она
копируется на стек, а в качестве аргумента передается указатель на копию.

Возврат структур происходит по тем же правилам (если возможно - в
`RAX`/`XMM0` и `RDX`/`XMM1`, иначе – как указатель на буфер возврата).

В System V ABI существует понятие **красной зоны** - области в 128
байт ниже текущей вершины стека. Данная зона, хотя и формально
находится за пределами текущего стека, защищена от изменения
обработчиками сигналов и прерываний (т.е. эта зона - «красная» для ОС, а
для программиста – вполне «зеленая»).

*Если ваша функция не вызывает другие функции, то она* ***может***
*считать красную зону своим кадром стека*. При этом:
- нет необходимости прибавлять/вычитать `RSP`,
если вам достаточно 120 байт;
- нет необходимости устанавливать указатель кадра стека
в `RBP` => экономятся инструкции пролога и эпилога.

#### Соглашение Microsoft

Передача аргументов в соглашении Microsoft происходит менее
эффективно, по сравнению с соглашением System V. В регистрах
передается 4 первых аргумента: целочисленные аргументы передаются, по
порядку, в `RCX`, `RDX`, `R8`, `R9`; вещественные – в `XMM0`-`XMM3`. Хотя
используется 8 регистров, передать можно только 4 аргумента. Например,
если первый аргумент – `int`, а второй – `float`, то первый аргумент будет
передан в `RCX`, а второй – в `XMM1`, хотя `XMM0` не занят.

Пятый и далее аргументы передаются на стеке. При этом для первых
4 аргументов резервируется теневое пространство (**shadow space**) размером
32 байта (по 8 байт на аргумент). Остальные аргументы идут после теневого
пространства. Теневая зона используется для сохранения первых 4
аргументов, если возникает необходимость освободить регистр. Кроме
того, аргументы сбрасываются в теневую зону при сборке в Debug-
конфигурации для облегчения работы отладчика. *Теневое пространство*
*резервируется вызывающей функцией, даже если аргументов у*
*вызываемой функции нет*.

Если функция имеет переменное число параметров (например, как
`printf`/`scanf`), то значение вещественных параметров в XMM-регистрах
должно дублироваться в целочисленных регистрах без приведения типов
(например, инструкциями `MOVD`/`MOVQ`). Например, если занят регистр
XMM0, то в точности то же значение должно находиться в `RAX`.

Правила передачи структур более простые и менее эффективные, по
сравнению с System V. Если структура имеет тривиальный конструктор
перемещения/копирования и тривиальный деструктор (обычный
конструктор может быть нетривиальным) и имеет размер 8 или менее байт,
она передается в регистре по значению. Иначе структура копируется на
стек, а качестве аргумента передается указатель на копию.

Возврат структур происходит по тому же правилу: в регистре RAX
либо через указатель на буфер возврата.

## Компиляция, дизассемблирование и декомпиляция

### Общая схема

В языках С/С++ основной единицей трансляции является файл
исходного кода, обычно имеющий расширение `.c`/`.cpp`/`.cxx`. Каждый файл
исходного кода содержит определение некоторых символов – глобальных
переменных или функций. Заголовочные файлы, по общему правилу,
должны содержать только объявления символов. Результатом компиляции
является набор объектных файлов.

По умолчанию все символы в пределах единицы трансляции
являются глобальными, т.е. видимыми из других единиц трансляции (в
других языках это может быть не так). Неглобальными (отсутствующими в
таблице экспорта) являются только символы, определенные с
модификатором `static`. Все глобальные символы заносятся в таблицу
экспорта результирующего объектного файла в ходе компиляции.

Если в пределах единицы трансляции символ был объявлен, но не
определен, то он заносится в таблицу импорта. Таблица импорта
обязательно должна быть заполнена на этапе компоновки.

*Если целью компиляции является исполняемый файл или*
*динамическая библиотека*, то после компиляции наступает этап
статической компоновки. На этапе статической компоновки можно указать
дополнительные зависимости сборки – статические и динамические
библиотеки. Таблицы экспорта и импорта всех объектных файлов и
библиотек объединяются. Если в общей таблице экспорта возникают
дубликаты, то компоновка завершается с ошибкой, т.к. в программе есть
два одинаковых символа. Если в общей таблице импорта возникают
дубликаты, они объединяются в одну запись. Далее таблица импорта
заполняется их таблицы экспорта. Если хотя бы одна запись в таблице
импорта остается незаполненной, то компоновка завершается с ошибкой.

*Если итоговой целью компиляции является статическая библиотека*
(`.lib`/`.a`), то набор объектных файлов просто объединяется в архив вместе с
некоторой дополнительной информацией. Т.е. **статическую библиотеку**
**можно легко открыть архиватором**.

Особым случаем является ситуация, при которой требуемый символ
из таблицы импорта находится в динамической библиотеке (`.dll`/`.so`). В этом
случае символ считается найденным и помещается в *таблицу импорта*
*исполняемого файла* вместе с именем динамической библиотеки, в которой
он находится. Во время загрузки исполняемого файла на этапе
динамической компоновки операционная система загружает также все
динамические библиотеки, упомянутые в таблице импорта, находит в ней
адреса импортируемых функций и переменных и окончательно заполняет
таблицу импорта уже этими адресами.

### Статические библиотеки как зависимость при компоновке

#### В CMake

В CMake за добавление внешней статической библиотеки в качестве
зависимости при компоновке отвечает директива `target_link_libraries`.

Если мы собираем проект с именем `Lab3`, и наша библиотека
находится по пути `C:\PathToLib\my.lib`, то итоговая директива будет
иметь вид:

```CMake
target_link_libraries(Lab3 PUBLIC “C:\PathToLib\my.lib”)
```

#### В SASM

В SASM при сборке проекта за компоновку отвечает программа,
указанная в поле «Компоновщик». Компоновщику передается на вход
несколько объектных файлов.

Добавить библиотеку для компоновки можно с помощью аргумента
`-l:путь_до_библиотеки`. **Следите за лишними пробелами**.

*Файлы, предоставляемые для выполнения лабораторной работы,*
*скомпилированы с помощью MinGW и не вызовут проблем*. Файлы `.lib`,
создаваемые компилятором MSVC могут вызвать проблемы при
компоновке, в этом случае приходится извлекать объектный файл и
передавать путь к нему без ключа `-l`.

### Символы в NASM

#### Глобальные символы

Любая метка в NASM является символом. Однако по умолчанию ни
один символ не является глобальным. Для того, чтобы символ был виден
при компоновке, требуется явно указать его, как `global`. Наиболее частый
пример – функция `main`, которая обязана быть глобальной. Поэтому в
примерах всегда присутствует строчка:

```asm
global main
```

Помните, что нет различий между символами-переменными и
символами-функциями.

#### Внешние символы

Для того, чтобы указать, что данный символ является внешним, в
языке NASM используется ключевое слово `extern`. Например, объявить
`printf`, как внешний символ можно строкой

```asm
extern printf
```

Однако здесь в силу вступает различие между искажением имен для
x86 и его отсутствием в x86-64. Поэтому в набор макросов SASM включен
макрос `CEXTERN`, который учитывает данный момент и автоматически
подстраивается.

```asm
CEXTERN printf   ; _printf on x86, printf on x86-64
```

#### Локальные метки

Поскольку метка является символом, ее имя должно быть
уникальным. Это может представлять неудобства. Рассмотрим следующий
код:

```c++
int foo(int x)
{
	for(int i = 0; i < 10; ++i)
		x+=x;
		
	return x;
}

int bar(int x)
{
	for(int i = 0; i < 10; ++i)
		x+=x;
	return x;
}
```

Данный код может быть реализован в NASM, как:

```asm
foo:
	mov eax, edi
	mov edx, 10
foo_loop:
	add eax, eax
	sub edx, 1
	jne foo_loop
	ret
bar:
	mov eax, edi
	mov edx, 10
bar_loop:
	add eax, eax
	sub edx, 1
	jne bar_loop
	ret
```

Из-за того, что каждая метка должна быть уникальной, метки начала
циклов тоже должны отличаться. Можно вручную писать уникальны имена,
как в примере выше, а можно использовать локальные метки.

Локальная метка – специальным метка, имя которой начинается с
точки. Пример: `.local_label`. Локальная метка связана с предыдущей
нелокальной меткой.

Используя локальные метки, пример выше можно переписать, как

```asm
foo:
	mov eax, edi
	mov edx, 10
.loop: ;<------------------
	add eax, eax         ;|
	sub edx, 1           ;|
	jne .loop            ;^
	ret
bar:
	mov eax, edi
	mov edx, 10
.loop: ;<------------------
	add eax, eax 		 ;|
	sub edx, 1 			 ;|
	jne .loop 			 ;^
	ret
```

При этом первая локальная метка связана с меткой `foo` и имеет
полное имя `foo.loop`. Вторая локальная метка связана с меткой `bar` и
имеет полное имя `bar.loop`.

### Искажение имен (mangling)

#### Искажение имен в C

По историческим причинам, имя символа-функции может быть
искажено в зависимости от используемого соглашения о вызовах.

Компилятор Microsoft применяет следующие правила иска.

Символы-функции, использующие соглашение **cdecl**, предваряются
префиксом `_`. То есть, функции `void foo()` будет соответствовать символ
`_foo`.

Символы-функции, использующие соглашение **stdcall**, предваряются
префиксом `_` и дополняются суффиксом `@`, за которым следует общий
размер фргументов. То есть, функции `void foo(int x, float y)` будет
соответствовать символ `_foo@12`.

В х86-64 искажение имен в С не используется.

#### Искажение имен в С++

Поскольку в языке С отсутствовали перегрузки функций, имя
функции (а значит и символ) всегда были уникальны.

В языке С++ с появлением перегрузок функций возникла проблема:
нужно было как-то назначить разным перегрузкам функций разные
символы. Сделано это было с помощью искажения имен.

В С++, каждый компилятор имеет свою схему искажения имен, но
общая схема совпадает. К началу любого символа (в т.ч переменной)
прибавляется префикс, содержащий информацию о пространстве имен и
классе, с которым связан символ. Если символ является функцией, то для
символа добавляется суффикс, содержащий информацию о аргументах.
Отменить искажение имен можно ключевой комбинацией `extern 'C'`.

| Функция | Символ (MSVC x86) | GCC |
| --- | --- | --- |
| `void f(int x, float y)` | `?f@@YAHHM@Z` | `_Z3fif` |
| `extern 'C' void f(int x, float y)` | `_f` | `f` |

Все современные средства отладки и анализа кода обращают
искажение имени (demangling) автоматически.

Для того, чтобы провести или обратить искажение имени, можно
использовать и отдельные инструменты, например `undname` для Windows,
`с++filt` для Linux.

### Получение объектного файла из статической библиотеки
Статическая библиотека (.lib/.a) является не более, чем архивом,
включающим в себя объектные файлы и метаданные. Как следствие,
данный архив легко открыть любым распространенным архиватором, в т.ч.
WinRAR или 7-Zip.

Интересующий объектный файл может быть извлечен и подвергнут
дизассемблированию.

## Задание на лабораторную работу

### Общие замечания

В данной лабораторной работе предполагается использование
специализированного ПО для анализа кода исполняемых файлов. Итоговый
выбор ПО и метода анализа исполняемого файла не ограничивается –
анализировать файл, как угодно, и чем угодно, главное, чтобы поставленная
задача была решена.

*Выполнение лабораторной работы (всей лабораторной работы, а не только*
*одного задания) на ОС семейства Linux при сдаче засчитывается на уровень выше.*

### Задание 1

В программе, полученной в ходе 
выполнения [лабораторной работы №1](../lab-1)
или [лабораторной работы №2](../lab-2) (по вашему выбору), заменить все макросы 
ввода-вывода SASM на вызовы функций `printf`/`scanf`. Если ввод-вывод 
с консоли не был реализован, его следует добавить. Для среднего и
сложного уровня запрещается использовать буферы в `.data`/`.bss`, 
память должна выделяться динамически через `malloc` и освобождаться
через `free`. Помните про макрос `CEXTERN`.

### Задание 2

Дана статическая библиотека, содержащая некоторый метод
проверки доступа. Вам необходимо реализовать программу, проходящую
данную проверку.

Для анализа и отладки программы предлагается использовать **IDA Free**.
Аналогами являются открытый проект `radare2` с интерфейсом *iaito* и
открытый проект Ghidra от АНБ (отсутствует отладчик, пригоден для
анализа). В самом простом варианте можно просто дизассемблировать
объектный файл с помощью онлайн-дизассемблера (объектный файл
придется извлечь из библиотеки) или напрямую с помощью `objdump` из
каталога `<SASM_DIR>/MinGW64/bin` командой 
`objdump.exe -M intel,x86-64 -rdF -j .text -j .rdata --no-show-raw-insn FILE > OUT_FILE`.

К сожалению, бесплатная IDA Free из-за ограничений может
анализировать только исполняемые файлы, но не статические библиотеки
или объектные файлы. Поэтому перед анализом функций необходимо
создать исполняемый файл.

Порядок выполнения:
0. Открыть в архиваторе файл библиотеки, найти в текстовых файлах
список экспортируемых символов, выбрать вашу функцию.
1. В SASM указать библиотеку как зависимость, указать вашу
функцию, как `CEXTERN <ваш символ>` после `global CMAIN`.
2. В SASM вызвать вашу функцию. Программа не будет работать, но
в исполняемый файл данная функция будет включена.
3. Сохранить исполняемый файл (Файл -> Сохранить .exe)
4. Открыть .EXE в IDA/iaito/Ghidra.
5. Проанализировать функцию, определить ее параметры, а также
условия, при которых проверка будет пройдена (в IDA/iaito можно
воспользоваться отладчиком).
6. Если необходимо – исправить программу в SASM, `goto 3`.

### Уровни сложности

#### Легкий

Гарантируется, что функция проверки имеет вид:

```c++
extern "C" void accessN(T1 a, T2 b, T3 c, T4 d);
```

где `N` – номер варианта, `T1`-`T4` – некоторые простые числовые типы
(не указатели).

В случае необходимости по запросу может быть предоставлен
ассемблерный код функции. Ассемблерный код выдается по запросу
студента.

#### Средний уровень

Гарантируется, что код варианта имеет следующий прототип:

```c++
namespace varN 
{
	struct S 
	{
		/**/
	};
	
	void access(T s);
}
```

Где `N` – номер варианта, `T` – `S` или `const S&`, поля структуры `S`
являются числами или массивами чисел, но не указателями.

#### Сложный уровень

Гарантируется, что код варианта имеет следующий прототип:

```c++
namespace varN 
{
	struct S
	{
		/**/
	};
	
	class C 
	{
		/**/
	public:
		void access(T s);
	};
}
```

Где `N` – номер варианта, `T` – `S` или `const S&`, поля структуры `S` и
объекта класса `C` являются числами или массивами чисел, но не
указателями.

---

**Работа выполенна на легкий уровень**

Использованная бибилиотека во втором задании:
`/lib/win64/easy.a`

Запустить лабораторную работу на ОС Windows можно через
`/script/lab-3.bat`
