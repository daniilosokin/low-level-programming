# Низкоуровневое программирование. Лабораторная работа №1

## Введение

*Ассемблер* (от англ. to assemble – собирать вместе, монтировать) –
системная программа для ЭВМ, решающая три задачи: 
1. компиляцию фрагментов программы, написанных на специализированном языке
программирования, в машинный код; 
2. компоновку целой программы из отдельных фрагментов;
3. загрузку машинного кода программы в память ЭВМ.

В настоящее время программа-ассемблер вышла из употребления, 
задачи 1 и 2 решаются «компилятором» и «компоновщиком», а задача (3) –
специальным компонентом операционной системы – «загрузчиком».

*Машинный код* программы – представление программы в виде набора
числовых команд, «понятных» центральному процессору ЭВМ.

*Язык ассемблера* – язык программирования, «понятный» человеку,
команды которого соответствуют числовым командам машинного кода.

## Общая характеристика программно-аппаратной среды

### Системная память

*Системная память* – множество одинаковых ячеек вместимостью один
байт. В каждой ячейке хранится число, представленное в виде группы из 8
битов.

*Адрес ячейки* – ее номер при последовательной нумерации от 0 до
максимума. Полный набор адресов и соответствующих им ячеек памяти
образует адресное пространство ЭВМ.

Наборы чисел, хранящихся в ячейках памяти, представляют собой либо
*программы*, выполняемые процессором, либо *данные*, обрабатываемые
процессором. Программы и данные друг от друга аппаратно неразличимы.

Элементы системной памяти, которые могут быть считаны или записаны
одной машинной командой:
- байт (8 бит) – минимальный элемент;
- слово (16 бит);
- двойное слово (32 бита);
- четверное слово (64 бита).

Порты ввода-вывода – ячейки памяти, которые отображаются на
внутренние регистры контроллеров внешних устройств.

### Модель процессора

Процессор может быть представлен, как совокупность:
- арифметико-логического устройства (АЛУ);
- внутренних регистров.

*Арифметико-логическое устройство* (АЛУ) –
подсистема процессора, выполняющая команды.

*Регистры процессора* – ячейки памяти,
расположенные внутри процессора. Каждый регистр
способен хранить число, представленное в виде
группы битов. Условно регистры могут быть
разделены на группы:
- регистры общего назначения (РОН) – используются при обработке
данных;
- сегментные регистры – хранят или указывают на старшую часть адреса
системной памяти;
- служебные и специальные регистры.

Часть регистров являются составными частями других регистров.

Таблица 1 – некоторые регистры
| 64 бита | 32 бита | 16 битов | Биты 8..15 | Биты 0..7 | Описание                  |
| ---     | ---     | ---      | ---        | ---       | ---                       |
| RAX     | EAX     | AX       | AH         | AL        | Регистр общего назначения |
| RBX     | EBX     | BX       | BH         | BL        | Регистр общего назначения |
| RCX     | ECX     | CX       | CH         | CL        | Регистр общего назначения |
| RDX     | EDX     | DX       | DH         | DL        | Регистр общего назначения |
| RSI     | ESI     | SI       | нет        | нет       | Регистр общего назначения |
| RDI     | EDI     | DI       | нет        | нет       | Регистр общего назначения |
| RBP     | EBP     | BP       | нет        | нет       | Регистр общего назначения |
| RSP     | ESP     | SP       | нет        | нет       | Указатель стека           |
| RIP     | EIP     | IP       | нет        | нет       | Указатель текущей команды |
| нет     | нет     | DS       | нет        | нет       | Сегментный регистр        |
| нет     | нет     | ES       | нет        | нет       | Сегментный регистр        |
| нет     | нет     | FS       | нет        | нет       | Сегментный регистр        |
| нет     | нет     | SS       | нет        | нет       | Сегментный регистр        |
| нет     | нет     | CS       | нет        | нет       | Сегментный регистр        |

### Регистр флагов

*Регистр флагов* представляет собой «регистр управления и состояния»
(РУС). Установка в 1 или сброс в 0 некоторых битов (управляющих флагов)
включает или выключает различные режимы работы процессора. Другие биты
(флаги состояния) характеризуют «мгновенное» состояние процессора. Они
автоматически изменяются после выполнения арифметических или логических
команд. Примеры:
- бит 0 (C, CF или CARRY) – флаг переноса, содержит бит, вытесняемый
из старшего или младшего бита результата во время арифметических или
логических операции и во время операций сдвига, так же часто служит
для индикации программных ошибок;
- бит 2 (PF) – бит четности, устанавливается при четном количестве
единичных битов в числовом результате выполнения операции
арифметической или логической;
- бит 4 (AF) – вспомогательный перенос;
- бит 6 (ZF) – бит нуля, устанавливается, когда результат операции равен 0;
- бит 7 (SF) – бит знака, устанавливается, когда старший бит результата
равен 1;
- бит 8 (TF) – бит трассировки, включает/выключает аппаратную
трассировку программ;
- бит 9 (IF) – включает/выключает реагирование процессора на сигналы
прерывания;
- бит 10 (DF) – бит направления, позволяет включать увеличение или
уменьшение регистра-счетчика итераций цикла;
- бит 11 (OF) – бит переполнения, устанавливается в 1 при переполнении
разрядной сетки во время арифметических операций;
- биты 12-13 – текущий уровень привилегий для операций ввода-вывода.

### Режимы работы процессора

*«Реальный»* режим устанавливается автоматически сразу после
включения питания. Его характеристики:
- разрядность шины данных - 16 бит;
- разрядность шины адреса – 20 бит (т.е. процессору доступны адреса
памяти от $0$ до $2^{20}-1$, всего $1024 \times 1024=1$ Мб различных адресов);
- разрядность служебных регистров, регистров общего назначения и
сегментных регистров – 16 бит.

*«Защищенный»* режим может быть запущен из «реального» после
настройки служебных таблиц, необходимых для адресации. Характеристики
защищенного режима:
- разрядность шины данных – 32 бита;
- разрядность шины адреса – 32 бита (т.е. процессору доступны $2^{32}=4$ Гб
различных адресов) или 64 бита (т.е. процессору доступны $2^{64}$ различных
адресов);
- разрядность служебных регистров и регистров общего назначения – 32
или 64 бита (сегментных – всегда 16 бит).

Все современные операционные системы работают только в «защищенном»
режиме, а «реальный» режим моделируется по мере необходимости в
виртуальных машинах типа DosBox или NTVDM.

### Прерывания и исключения

*Прерывание* – реакция процессора на запрос (электрический импульс) от
внешнего устройства (таймера, жесткого диска, интерфейса USB,
видеоадаптера, сетевого адаптера, звуковой подсистемы и т.п.). Так же
процессор может послать запрос прерывания сам себе при помощи
специальной машинной команды `INT`.

*Исключение* – реакция процессора на особое событие, происходящее
внутри процессора при выполнении машинных команд. Примеры событий:
ошибка деления на 0; ошибка при попытке доступа к «запрещенному» региону
памяти; ошибка при попытке доступа к физически отсутствующему региону
памяти и т.п.

Все источники прерываний и исключений пронумерованы операционной
системой. Каждому номеру в специальной таблице векторов прерываний
соответствует некоторый адрес системной памяти, по которому располагается
программа обработки прерывания/исключения. Примеры номеров
прерываний/исключений:
- `0` – ошибка деления на 0;
- `3` – «самомпрерывание»;
- `6` – недопустимый код команды;
- `D`${}_{16}$ – попытка обратиться в запрещенный регион памяти (например, по
адресу 0);
- `E`${}_{16}$ – попытка обратиться в отсутствующий регион памяти.

При поступлении запроса на прерывание или при возникновении исключения
процессор обязан прореагировать стандартным образом:
- сохранить в стеке регистр флагов;
- сохранить в стеке адрес очередной команды в текущей программе;
- перейти на выполнение программы-обработчика, адрес которой указан в
таблице векторов прерываний.

Программа-обработчик прерывания/исключения должна заканчиваться
специальной машинной командой `IRET`. При выполнении этой команды
процессор:
- восстанавливает из стека адрес очередной команды в текущей программе;
- восстанавливает из стека регистр флагов;
- продолжает выполнение прерванной программы с восстановленного
адреса.

## Некоторые ассемблерные команды

Для программирования процессоров Intel могут быть использованы
различные языки ассемблера:
- c синтаксисом от Intel (используется в компиляторах для DOS и
Windows);
- c синтаксисом, определенным в стандарте AT&T (используется в UNIX).

### Команды пересылки данных

- `MOV приемник, источник` –
пересылает данные из `источник` в `приемник`. `Приемник` и `источник` не
могут одновременно быть ячейками памяти. `Приемник` и `источник` должны
иметь одну и ту же разрядность.
- `LEA приемник, источник` –
помещает в `приемник` адрес `источник`.
- `MOVSB` или `MOVSW` или `MOVSD` –
пересылают данные из `DS:[SI]` в `ES:[DI]`, автоматически увеличивая (или
уменьшая) индексы `SI` и `DI`. Индексы увеличиваются, если в регистре флагов
командой `CLD` предварительно сброшен бит `D` в 0; уменьшаются, если бит `D`
установлен в 0 командой `STD`.
- `XCHG операнд1, операнд2` –
обменивает местами операнды. Операнды не могут одновременно быть
ячейками памяти. Операнды должны иметь одну и ту же разрядность.
- `PUSH операнд` –
значение указателя в стеке уменьшается: `ESP:=ESP-(размер операнда)`.
Помещает значение операнда в стек по адресу `SS:[ESP]`. Допустимая длина
операнда: 2 или 4.
- `POP операнд` –
извлекает значение из стека `SS:[ESP]` и помещает его в `операнд`.
Указатель в стеке увеличивается на длину операнда 
`ESP:=ESP+(размер операнда)`. Допустимая длина `операнд`: 2 или 4.
- `PUSHF` –
работает аналогично `PUSH`, но помещает в стек не любой операнд, но
регистр флагов.
- `POPF` –
работает аналогично `POP`, но извлекает из стека не любой операнд, но
регистр флагов.
- `PUSHA` –
помещает в стек сразу весь блок регистров общего назначения.
- `POPA` –
Извлекает из стека сразу весь блок регистров общего назначения.

### Арифметические и логические команды

- `ADD операнд1, операнд2` –
Складывает операнды: `операнд1:=операнд1+операнд2`
- `SUB операнд1, операнд2` –
Вычитает операнды: `операнд1:=операнд1-операнд2`
- `ADC, SBB` –
группа команд, аналогичных командам ADD и SUB, за исключением
того, что к после вычисления результата к нему арифметически
добавляется/вычитается значение бита CF из регистра флагов.
- `INC операнд` –
Инкрементирует `операнд`: `операнд:=операнд+1`
- `DEC операнд` –
Декрементирует `операнд`: `операнд:=опеаранд-1`
- `MUL операнд` –
Умножает `операнд` на регистр `AL`, `AX` или `EAX`, помещает результат в
- `AX`, `DX:AX` или `EDX:EAX`, соответственно. Вид операции определяется
длиной операнда, который может быть только регистром или ячейкой памяти
(но не непосредственным числом).
- `DIV операнд` –
Делит `AL`, `AX` или `EAX` на `операнд`, помещая результат в `AL`, `AX` или
- `EAX` и остаток в `AH`, `DX` или `EDX`, соответственно. Вид операции определяется
длиной операнда, который может быть только регистром или ячейкой памяти
(но не непосредственным числом).
- `IADD`, `ISUB`, `IMUL`, `IDIV` –
группа арифметических команд, аналогичных командам `ADD`, `SUB`, `MUL`
и `DIV`, за исключением того, что в результате не затрагивается старший
(знаковый) бит операнда. В итоге арифметические действия производятся с
учетом знака операндов.
- `AND операнд1, операнд2` –
Логически умножает операнды: `опенранд1:=операнд1&опенранд2`.
- `OR операнд1, операнд2` –
Логически складывает операнды: `операнд1:=операнд1|операнд2`.
- `XOR операнд1, операнд2` –
Выполняет операцию «сложение по модулю 2»: `операнд1 := операнд1 (+) операнд2`.
- `NOT операнд` –
Инвертирует все биты в `операнд`.
- `NEG операнд` –
Изменяет знак числа на противоположный.
- `CMP операнд1, операнд2` –
Выполняет сравнение двух операндов (путем арифметического
вычитания), не изменяя их. Результат сравнения – установка в 1 или сброс в 0
отдельных битов в регистре флагов.
- `TEST операнд1, операнд2` –
Выполняет сравнение двух операндов (путем логического умножения), не
изменяя их. Результат сравнения – установка в 1 или сброс в 0 отдельных
битов в регистре флагов.
- `SHR операнд1, операнд2` и `SHL операнд1, операнд2` –
выполняют сдвиг всех битов `операнд1` вправо/влево на число позиций,
указанное в `операнд2`. Последний «вытесненный» бит сохраняется в бите CF
регистра флагов. «Новые» биты заполняются нулями.
- `ROR операнд1, операнд2` и `ROL операнд1, операнд2` –
выполняют циклический сдвиг всех битов `операнд1` вправо/влево на
число позиций, указанное в `операнд2`.
- `RСR операнд1, операнд2` и `RСL операнд1, операнд2` –
выполняют циклический сдвиг всех битов `операнд1` вправо/влево на
число позиций, указанное в `операнд2`. Сдвиг выполняется через бит `CF` в
регистре флагов.
- `BT операнд, смещение` –
помещает бит `операнд`, номер которого задан `смещение`, в бите `CF`
регистра флагов.
- `BTS операнд, смещение` –
устанавливает в 1 в `операнд` бит, номер которого задан `смещение`.
Старое значение бита сохраняется в бите `CF` регистра флагов.
- `BTC операнд, смещение` –
сбрасывает в 0 в `операнд` бит, номер которого задан `смещение`. Старое
значение бита сохраняется в бите CF регистра флагов.
- `BTR операнд, смещение` –
инвертирует в `операнд` бит, номер которого задан `смещение`. Старое
значение бита сохраняется в бите `CF` регистра флагов.
- `BSF приемник, источник` –
помещает в `приемник` номер первого по счету (начиная с младшего) бита 1
 в `источник`.
- `BSR приемник, источник` –
Помещает в `приемник` номер первого по счету (начиная со старшего) бита 0
в `источник`.
- `STC`, `STD`, `STI` –
группа команд, которые устанавливают в 1 значения битов `CF`, `DF` и `IF`
(соответственно) в регистре флагов.
- `CLC`, `CLD`, `CLI` –
группа команд, которые сбрасывают в 0 значения битов `CF`, `DF` и `IF`
(соответственно) в регистре флагов.

### Команды перехода

- `JMP метка` –
Выполняет безусловный переход по адресу, сопоставленному `метка`.
- `J* метка` –
Выполняет переход по адресу, сопоставленному `метка`, если выполнено
условие:
	- `JA` – переход по «больше»;
	- `JB`/`JC` – переход по «меньше» (если сброшен бит C);
	- `JAE`/`JNC` – переход по «больше или равно» (если установлен бит C);
	- `JBE` – переход по «меньше или равно»;
	- `JE`/`JZ` – переход по «равно».
- `CALL метка` –
Переходит на подпрограмму по адресу, сопоставленному `метка`.
Предварительно адрес текущей команды автоматически помещается в стек.
- `RET` –
Выполняет возврат из подпрограммы по адресу, извлеченному из стека.
Так же существует разновидность `RET количество`, которая после перехода
удаляет из стека указанное `количество` байтов.
- `INT номер` –
Возбуждает программное прерывание с указанным `номер`. При этом в
стек помещаются регистр флагов и адрес текущей команды, затем выполняется
переход по адресу, установленному для этого `номер` прерывания в системных
таблицах процессора. Так же для возбуждения прерывания с номером 3 кроме
`INT 3` существует «укороченная» команда `INT3`, машинный код которой
$CC_{16}$ занимает один байт.
- `IRET` –
Выполняет возврат из обработки прерывания по адресу, извлеченному из
стека. Так же из стека извлекается регистр флагов.
- `LOOP метка` –
Выполняет переход на адрес, сопоставленный `метка`, если `ECX <> 0`,
уменьшая счетчик `ECX` на 1: `ECX:=ECX-1`; ничего не делает и переходит к
следующей команде, если `ECX=0`. Если бит `D` установлен в 1, то команда
каждый раз не уменьшает, а увеличивает `ECX`.

### Прочие команды

- `IN AL, порт` –
Принимает в регистр `AL` из `порт` ввода-вывода, связанного с каким-либо
устройством, числовое значение.
- `OUT порт, AL` –
Посылает в `порт` ввода-вывода, связанный с каким-либо устройством,
числовое значение из регистра `AL`.
- `CPUID` –
Возвращает в регистрах техническую информацию о процессоре, тип
интересующей информации заранее задается в регистре EAX. Например, если
`EAX=0`, то в `EBX:ECX:EDX` будет возвращена строка имени процессора.
- `RDTSC` –
Возвращает в регистровой паре `EDX:EAD` количество тактовых
импульсов, накопленное процессором.

## Способы адресации операндов

Способы адресации определяют, каким образом в операнде команды
может быть указан адрес регистра или ячейки памяти.

- **Регистровый**: операнд – регистр процессора. Пример: `NOT EAX`.
- **Непосредственный**. операнд – число. 
Пример: `MOV EAX, 12345678h`.
- **Прямой**: операнд – числовой адрес ячейки памяти. 
Пример: `MOV [12345678h], EAX`.
- **Косвенный**: операнд – регистр, содержащий адрес ячейки памяти.
Пример: `MOV [EBX], 0`.
- **Косвенный со смещением**: операнд – комбинация регистра, содержащего
адрес ячейки памяти, и числового смещения относительно этого адреса.
Пример: `MOV [EBX+4], 0`.
- **Базово-индексный**: операнд – комбинация регистра, содержащего адрес
ячейки памяти, и регистра, содержащего смещение относительно этого адреса.
Пример: `MOV [EBX+ESI], 12345678h`.

При использовании косвенных и базово-индексных способов адресации
часто требуется дополнительно указывать размер операнда при помощи
модификаторов:
- `вyte ptr` – байт (8 битов);
- `word ptr` – слово (16 битов);
- `dword ptr` – двойное слово (32 бита).

Примеры:
- `MOV BYTE PTR [EBX], AL` – копировать 8 битов из регистра в память;
- `MOV EAX, DWORD PTR [EBX]` – копировать 32 бита в регистр из
памяти.

## Отличия синтаксиса AT&T от Intel

Имена регистров в AT&T начинаются с символа `%`, например:
- `EAX` – Intel;
- `%EAX` – AT&T.

Числовые константы в Intel имеют суффикс `h` для 16-ричных значений
и не имеют суффикса для 10-чных. Числовые константы в AT&T оформляются
по правилам языка Си и имеют префикс `$`. Например:
- `123h` – Intel;
- `$0x123` – AT&T.

Команды AT&T, имеющие операнды, используют суффикс для указания
размера операнда (-ов): `B` - один байт; `W` - слово; `D` - двойное слово;
`Q` - четверное слово. Команды Intel могут для этих же целей (если один из
операндов находится в памяти) использовать ключевые слова `BYTE PTR`,
`WORD PTR`, `DWORD PTR` и `QWORD PTR`. Например:
- `INC AL` - Intel;
- `INCB %AL` – AT&T.

Если команда использует два операнда, то по правилам Intel сначала
указывается приемник, потом источник; в синтаксисе AT&T наоборот.
Например:
- `MOV EAX, 123h` – Intel;
- `MOVD $0x123, EAX` – AT&T.

Для прямой адресации в синтаксисе Intel используются квадратные
скобки, в AT&T число или метка без суффиксов и префиксов. Пример:
- `MOV AL, BYTE PTR [123456h]` – Intel;
- `MOVD 0x123456, %AL` – AT&T.

Для доступа к адресу переменной в Intel используется ключевое слово
«OFFSET», в AT&T просто имя метки. Пример:
- `MOV EAX, OFFSET METKA` - Intel;
- `MOVD METKA, %EAX` – AT&T.

## Некоторые приемы программирования на языке ассемблера

### Организовать цикл

В простейшем случе можно воспользоваться в качестве счетчика любым
регистром, например:

```asm
	Mov eax, 123 ; Количество повторов
Oncemore: 		 ; Метка возврата
	...
	dec eax      ; Вычесть из eax единицу
	jnz Oncemore ; Если результат предыдущей операции не 0, то на метку …
				 ; Иначе дальше
```

Для организации циклов существует специальная команда LOOP, которая
использует регистры ECX (или CX), автоматически уменьшая (или увеличивая)
его содержимое на 1 и проверяя на равенство нулю. Если достигнут 0, то конец
цикла.

```asm
	сld           ; Очистить бит D
	Mov ecx, 123  ; Количество повторов
Oncemore:         ; Метка возврата
	...
	loop oncemore ; Если ecx не 0, то на метку
	...           ; Иначе дальше
```

### Просканировать массив чисел или строку

В простейшем случае можно организовать индекс адреса в любом
регистре и воспользоваться командой `MOV`, например:

```asm
	; Mov eax, seg STR 	; Не обязательные строки, чеще всего требуются
	; Mov ds, eax 		; в MS-DOS, если сегментный регистр «испорчен».
	Mov ecx, 123 		; Количество повторов
	Lea edx, STR[0] 	; Адрес 1-го элемента массива в EDX
Oncemore:
	Mov eax, [edx] 		; Очередной элемент в EAX
	... 				; Работа с очередным элементом
	Add edx, 4 			; Увеличение адреса
	Loop cx, oncemore 	; Возврат в цикл
```

Для сканирования и копирования массивов существуют специальные команды,
использующие в качестве индекса регистры `ESI` и `EDI`:
- `LODSB` (или `LODSW`, или `LODSD`) - копирует в `AL` (или `AX`, или `EAX`)
содержимое по адресу `[ESI]` и автоматически увеличивает или уменьшает
`ESI` (в зависимости от значения бита D в регистре флагов);
- `STOSB` (или `STOSW`, или `STOSD`) – копирует из `AL` (или `AX`, или `EAX`)
содержимое по адресу `[EDI]` и автоматически увеличивает или уменьшает
EDI (в зависимости от значения бита D в регистре флагов);
- `MOVSB` (или `MOVSW`, или `MOVSD`) – копирует `[ESI]` в `[EDI]` и
автоматически увеличивает или уменьшает `ESI` и `EDI` (в зависимости от
значения бита `D` в регистре флагов).

```asm
	Cld 				; Бит D:=1, т.е. каждый раз увеличивать ESI
	Mov ecx, 123 		; Количество повторов
	Lea esi, Str[0] 	; Адрес 1-го элемента массива
Oncemore:
	Lodsd 				; Очередной элемент загрузить в EAX, при этом ESI:=ESI+4
	... 				;
	Loop cx, oncemore 	; Возврат в цикл
```

### Сложить или вычесть два числа

```asm
Mov eax, 123
Mov ebx, 321
Add eax, ebx ; eax:=eax+ebx
```

### Разделить или умножить число на степень двойки

Посольку числа хранятся в 2-чном коде, то умножение на 2 эквивалентно
сдвигу всех битов влево на один разряд. Соответственно, деление – сдвигу
вправо.

```asm
Mov eax, 123 ; Само число
shl eax, 3   ; Теперь в EAX появится 123*8=984
```

Вновь появившиеся разряды заполняются нулями. При сдвиге влево последний
«выпавший» бит помещается в бит O регистра флагов, при сдвиге вправо – в
бит C.

### Поменять местами два операнда

Через «битончик»:

```asm
Mov eax, 123 ; Первое число
Mov ebx, 321 ; Второе число
Mov ecx, eax ; В битончик
Mov eax, ebx
Mov ebx, ecx ; Из битончика
```

Через стек:

```asm
Push eax
Push ebx
Pop eax
Pop ebx
```

Специальной командой:

```asm
Xchg eax, ebx
```

Воспользоваться свойствами логической функции «исключающее ИЛИ»:

```asm
Xor eax, ebx
Xor ebx, eax
Xor eax, ebx
```

### Проверить конкретный бит операнда

Если проверить на 0, то:

```asm
Tst al, 00010000b
Je Metka
```

Если проверить на 1, то:

```asm
Tst al, 00010000b
Jne Metka
```

### Установить в 1 или сбросить в 0 конкретный бит операнда

Если сбросить в 0, то:

```asm
And al, 11101111b
```

Если установить в 1, то:

```asm
Or al, 00010000b
```

### Обратиться к операционной системе

В операционной системе MS Windows загрузить параметры в стек в
обратном порядке и вызвать библиотечную функцию Win API командой
`CALL`.

```asm
Push 0 				; 0 – кнопка ”OK”
Push offset String1 ; Адрес строки заголовка
Push offset String2 ; Адрес строки сообщения
Push 0 				; Дескриптор окна
Call MessageBoxA 	; Если строки ASCII
	; или
Call MessageBoxW 	; Если строки UNICODE
```

Некоторые компиляторы поддерживают директивы 
вида `INVOKE 0,String2, String2,0`, которые при компиляции
автоматически «расширяются» в вышеприведенный текст из 5 команд.

В операционной системе на базе ядра Linux поместить параметры в регистры (в
том числе и номер API-функции) и выполнить вызов командой `INT 80h`.

```asm
movl $4, %eax 	; Номер функции: write=4, read=3, open=5, fork=2, exit=1...
movl $1, %ebx 	; Дескриптор файла: stdin=0, stdout=1, stderr=2...
movl $str, %ecx ; Адрес строки, кончающейся кодом 0
movl $6, %edx 	; Длина строки
int 0x80
```

В операционной системе MS-DOS поместить параметры в регистры (в том
числе и номер API-функции) и выполнить вызов командой `INT 21h`.

```asm
mov ax, 9 				; Номер функции «вывод на экран»
mov dx, offset String 	; Адрес строки, кончающейся символом «$»
int 21h
```

## Общие требования при выполнении лабораторной работы

Реализовать заданный в варианте алгоритм на языке 
ассемблера [NASM](https://www.nasm.us/pub/nasm/releasebuilds/2.15.05/win64/). 
Программу собирать для архитектуры x86_64.

Результат работы программы вывести на экран соответствующим макросом из стандартного
комплекта [SASM](http://dman95.github.io/SASM/).

Массивы реализовывать как статические переменные в секции .data (или .bss).

При работе со строками максимальную длину строки установить не менее 255.

При работе со строками считать, что допустимый алфавит состоит из цифр, английских букв
обоих регистров и символов `[]()+-*/=&?!/\”’:;@.,` (при желании можно добавить кириллицу)

При работе с числовыми массивами максимальную длину массива установить не менее 100

Если в задании предполагается ввод массива пользователем, то пользователь сначала вводит
размер массива, а затем сам массив

Проверку ввода пользователя можно не делать

## Варианты заданий

### Легкий уровень

1. Для введенной пользователем строки вывести инвертированную строку и строку,
состоящую только из четных элементов исходной строки;
2. Для введенной пользователем строки и числа `N` вывести строку, циклически сдвинутую
на `N` вправо;
3. Для введенной пользователем строки проверить, является ли она палиндромом;
4. Для введенной пользователем строки проверить, сколько раз в ней встречается буква, с
которой начинается Ваша фамилия (регистр букв игнорировать);
5. Для введенного пользователем числа вывести представление числа по основанию 8;
6. Реализовать аналог функции strcmp. Продемонстрировать результат работы алгоритма
на 2-х введенных строках;
7. Для введенного пользователем массива (пользователь вводит длину массива, затем сам
массив) рассчитать и вывести минимум и максимум;
8. Проверить введенное пользователем число на простоту, вывести ответ;
9. Для введенных пользователем векторов вывести их скалярное произведение;
10. Для введенных пользователем векторов вывести квадрат расстояния между ними.

### Средний уровень

1. Для введенного пользователем массива чисел подсчитать количество битов со
значением 1
2. Для введенного пользователем массива рассчитать среднее и дисперсию
3. Зашифровать введенную пользователем строку шифром Цезаря
4. Для введенных пользователем строк проверить, содержит ли первая строка вторую
5. Для пользовательской строки рассчитать гистограмму символов
6. Для пользовательского массива рассчитать и вывести массив с результатом расчета
скользящего среднего в окне размером 5
7. Посчитать количество уникальных элементов в массиве чисел типа `short`.

### Сложный уровень

1. Отсортировать введенный пользователем массив пузырьком
2. Отсортировать введенный пользователем массив вставками
3. Отсортировать введенный пользователем массив выбором
4. Реализовать линейный конгруэнтный генератор псевдослучайных чисел. Параметры
генератора считать постоянными. Используя введенное пользователем число в качестве
начальной точки, вывести 100 сгенерированных чисел.
5. Реализовать генератор псевдослучайных чисел xorshift128. Используя введенное
пользователем число в качестве начальной точки, вывести 100 сгенерированных чисел.
6. Реализовать генератор псевдослучайных чисел BlumBlumShub. Параметры p и q
выбрать самостоятельно. В качестве результата использовать 1 или 2 младших байта
полученного числа. Используя введенное пользователем число в качестве начальной точки,
вывести 100 сгенерированных чисел.
7. Реализовать вычисление контрольной суммы CRC32 для введенной строки. Вывести
полученное значение.
8. Отсортировать введенный пользователем массив шейкерной сортировкой

---

**Работа выполнена на сложный уровень, вариант №1**